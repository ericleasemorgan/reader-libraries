<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<meta name="DOI" content="10.1045/may2015-boehme" />
<meta name="description" content="D-Lib Magazine" /> 
<meta name="keywords" content="Metamorph, Semi-structured Data, Transformation Language" />
<link rel="metadata" href="05boehme.meta.xml" />
<link rel="metadata" href="../05bib.meta.bib" />
<link rel="metadata" href="../05ris.meta.ris" />
<link href="../../../style/style1.css" rel="stylesheet" type="text/css" />
<title>Metamorph: A Transformation Language for Semi-structured Data</title>
</head>

<body>
<form action="https://www.dlib.org/cgi-bin/search.cgi" method="get">

<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#2b538e">
<tr>
<td><img src="../../../img2/space.gif" alt="" width="10" height="2" /></td></tr>
</table>

<table width="100%" border="0" cellpadding="0" cellspacing="0">
<tr>
<td valign="bottom" colspan="4" align="right" bgcolor="#4078b1">

<table border="0">
<tr>
<td align="right" class="search"><img src="../../../img2/search2.gif" alt="" width="51" height="20" align="middle" />Search D-Lib:</td>

<td>
<input type="text" name="words" value="" size="25" />
</td>

<td align="left" valign="middle">
<input type="submit" name="search" value="Go!" />
<input type="hidden" name="config" value="htdig" />
<input type="hidden" name="restrict" value="" />
<input type="hidden" name="exclude" value="" /> 
</td>
</tr>
</table>

</td></tr></table>

<table width="100%" border="0" cellpadding="0" cellspacing="0">
<tr>
<td valign="bottom" colspan="4">

<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#e04c1e" id="outer" summary="Main Table">
<tr>
<td><img src="../../../img2/space.gif" alt="" width="10" height="1" /></td></tr>
</table>

<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#F6F6F6" id="bannertable">
  <tr>
    <td width="830" bgcolor="#4078b1" class="backBannerImage" align="left"><img src="../../../img2/D-Lib-blocks.gif" alt="D-Lib Magazine" width="450" height="100" border="0" /></td>
  </tr>
  <tr>
    <td width="830" bgcolor="#e04c1e"><img src="../../../img2/transparent.gif" alt="spacer" height="1" /></td>
  </tr>
  <tr>
    <td width="830" bgcolor="#eda443" align="left"><img src="../../../img2/magazine.gif" alt="The Magazine of Digital Library Research" width="830" height="24" border="0" /></td>
  </tr>
  <tr>
    <td width="830" bgcolor="#e04c1e"><img src="../../../img2/transparent.gif" alt="spacer" height="1" /></td>
   </tr>
</table>

<table width="100%" border="0" cellpadding="0" cellspacing="0" id="navtable">
  <tr>
    <td width="5" height="20" bgcolor="#2b538e">&nbsp;</td>
    <td width="24" height="20" bgcolor="#2b538e"><img src="../../../img2/transparent.gif" alt="" width="24" height="20" /></td>
    <td height="20" align="left" bgcolor="#2b538e" class="navtext" nowrap="nowrap"><a href="../../../dlib.html">HOME</a>&nbsp;|&nbsp;<a href="../../../about.html">ABOUT D-LIB</a>&nbsp;|&nbsp;<a href="../../../contents.html" class="navtext">CURRENT ISSUE</a>&nbsp;|&nbsp;<a href="../../../back.html">ARCHIVE</a>&nbsp;|&nbsp;<a href="../../../author-index.html">INDEXES</a>&nbsp;|&nbsp;<a href="../../../groups.html">CALENDAR</a>&nbsp;|&nbsp;<a href="../../author-guidelines.html">AUTHOR GUIDELINES</a>&nbsp;|&nbsp;<a href="https://www.dlib.org/mailman/listinfo/dlib-subscribers">SUBSCRIBE</a>&nbsp;|&nbsp;<a href="../../letters.html">CONTACT D-LIB</a></td>
    <td width="5" height="20" bgcolor="#2b538e">&nbsp;</td>
  </tr>
</table>

<table width="100%" border="0" cellpadding="0" cellspacing="0">
  <tr>
    <td width="55" height="1" bgcolor="#e04c1e"><img src="../../../img2/space.gif" alt="transparent image" width="1" height="1" /></td></tr>
</table>

<!-- CONTENT TABLE -->
<table width="100%" border="0" align="center" cellpadding="0" cellspacing="0">
  <tr>
  <td>
 
<!-- BEGIN MAIN CONTENT TABLE -->

<table width="100%" border="0" cellspacing="0" cellpadding="10" bgcolor="#ffffff">
<tr>

<td width="10"><img src="../../../img2/space.gif" alt="" width="1" height="1" /></td>

<td valign="top"> 

<h3 class="blue-space">D-Lib Magazine</h3>
<p class="blue">May/June 2015<br />
Volume 21, Number 5/6<br />
<a href="../05contents.html">Table of Contents</a>
</p> 

<div class="divider-full">&nbsp;</div>

<h3 class="blue-space">Metamorph: A Transformation Language for Semi-structured Data</h3>

<p class="blue">
Markus Michael Geipel, Christoph B&#246;hme, and Jan Hannemann<br /> 
German National Library
<br /><br />
Corresponding Author: Christoph B&#246;hme, c.boehme&#064;dnb.de

<br /><br />DOI: 10.1045/may2015-boehme
 </p>

<div class="divider-full">&nbsp;</div>

<p class="blue"><a href="05boehme.print.html" class="fc">Printer-friendly Version</a></p>

<div class="divider-full">&nbsp;</div>

 <!-- Abstract or TOC goes here --> 

<h3 class="blue">Abstract</h3>

<p class="blue">
In this paper we present Metamorph, a data flow-oriented language for transforming semi-structured data. Its declarative style facilitates communication between programmers and domain experts. Metamorph is embedded in a pipes and filters framework implemented as a Java library. It is both format-agnostic and extendable. Metamorph has become an integral part of the IT-infrastructure of the German National Library, where it is used in several applications and services. Due to its publication as Open Source Software Metamorph has acquired a user community which actively supports further development.</p>

<!-- Article goes next --> 

<div class="divider-full">&nbsp;</div>
<h3>1 Introduction</h3>

<p>The Metamorph language springs from the need to process and transform metadata, a central ingredient of any information storage and retrieval system. Being defined as "data on data", metadata provides descriptive information on the items stored in a library, an archive, or a web search engine.</p>

<p>The variety of possibly stored items is reflected in the plethora of existing metadata formats, which emerged in different communities: libraries, museums, booksellers, etc. In order to maintain interoperability in the face of such diversity and constant change, metadata transformation is essential. Transformations are not only performed to exchange data between institutions and domains: they are also an integral part of cross-collection searches, indexing, presentation in user-interfaces, and preprocessing for statistical analyses.</p>

<p>In technical terms, metadata is semi-structured data. Two major characteristics make metadata processing challenging. Firstly, loose typing: information is often specified as free text. For instance, one might think that the publication year of a book would be a date or an integer. However, values such as "ca. 1610", "150?" or "1710&#151;" are quite common in library catalogs (based on our own <a href="http://www.culturegraph.org">analysis</a> of  German catalog data). This means that complex normalization is required for meaningful data processing. When general purpose programming languages are used, code tends to be convoluted due to the abundance of conditional branching. Secondly, metadata is characterized by loose adherence to data schemas which themselves may change frequently. An example for this is the cataloging practice in German libraries: how bibliographic records are filled is defined by a set of rules called RAK [<a href="05boehme.html#35">35</a>]. These rules are interpreted by catalogers, and due to this room for interpretation automatic validation is hardly feasible. Again, this flexibility leads to complex data processing code, which is hard to test and maintain.</p>

<p>Overall, the characteristics of metadata match the definitions of semi-structured data [<a href="05boehme.html#3">3</a>, <a href="05boehme.html#15">15</a>, <a href="05boehme.html#42">42</a>]. This paper presents a declarative, flow-oriented language for semi-structured data transformation.</p>

<p>A useful data transformation language should address three challenges: universality, transparency and efficiency.</p>

<p class="indentLeft"><b>Universality</b>: Several formats of semi-structured data exist, such as the Object Exchange Model (OEM) [<a href="05boehme.html#42">42</a>], the Extensible Markup Language (XML) [<a href="05boehme.html#11">11</a>, <a href="05boehme.html#12">12</a>], the Resource Description Framework (RDF) [<a href="05boehme.html#8">1</a>, <a href="05boehme.html#38">38</a>], the Javascript Object Notation (JSON) [<a href="05boehme.html#22">22</a>], and the YAML Ain't Markup Language (YAML) [<a href="05boehme.html#6">6</a>]. Additionally, there are many domain-specific formats, e.g. <a href="http://www.loc.gov/marc/bibliographic/">MARC21</a>, PICA and MAB (See [<a href="05boehme.html#33">33</a>, pp 195]) in the library domain. Ideally, a transformation language is independent of these particular input and output formats, and allows the user to define transformations on a more abstract level. That way transformations defined in such a language can be applied to data coming from a bibliographic record in MARC21 the same way it could be applied to data in XML, comma separated values or data coming from a database. In addition to handling semi-structured data from various domains, such an approach also allows for conversion between different data formats.</p>

<p class="indentLeft"><b>Transparency</b>: Metadata transformation is typically a complex and sometimes tedious process requiring both domain knowledge and programming skill. The standard procedure is that a programmer implements a conceptual mapping created by a domain expert. This means that in practice, information tends to flow one-way from expert to programmer. What the programmer really implements is difficult to be double-checked by the domain expert as he or she in turn often lacks the  fluency in the respective programming language the transformation is realized in. The challenge is thus to facilitate the exchange between programmer and domain expert, by defining transformations in a transparent way, stripped of implementation details. This is the classical use case for a domain specific language (DSL) [<a href="05boehme.html#39">39</a>]. Ideally, end user development [<a href="05boehme.html#25">25</a>, <a href="05boehme.html#46">46</a>] is possible, i.e., the domain expert would be able to code transformations without the help of a programmer. </p>

<p class="indentLeft"><b>Efficiency</b>: Efficiency is paramount when dealing with large data sets. The larger the data set the less feasible approaches become that build models of the entire data set, such as XSLT tends to do. Event-based processing models tend to scale much better. </p>

<p>Metamorph, the transformation language we present in this paper, addresses these challenges. Furthermore, Metamorph is part of the Open Source Metafacture project and supported by an active community. The source is hosted at <a href="https://github.com/culturegraph/metafacture-core">github</a>. The official user guide can be found <a href="https://github.com/culturegraph/metafacture-core/wiki/Metamorph-User-Guide">here</a>. Metamorph is also available via Maven Central: to use Metamorph in your Java Maven projects just include the XML snipped in Listing 1 in the dependencies section of the pom.xml.</p>

<div align="center">
<img src="boehme-list1.png" alt="boehme-list1" width="736" height="106" border="0" />
<p><i>Listing 1: Adding Metamorph to a Java Maven project.</i></p>
</div>

<p>The remainder of this paper is organized as follows. In Section 2 we provide a review of related work and discuss how Metamorph differs from existing approaches. In Section 3 the framework of Metamorph is presented, including a discussion of the data model and the data processing paradigm which provide the conceptual basis for the transformation language. Section 4, describing the actual transformation language, forms the central piece of this publication. It is followed by a brief presentation of applications using Metamorph in Section 5. Section 6.4 concludes the paper with a discussion of the scope and limitations of Metamorph, as well as future prospects.</p>

<div class="divider-full">&nbsp;</div>
<h3>2 Related Work</h3>

<p>In recent years semi-structured data has received increased attention from practitioners and a variety of solutions for storage and retrieval of semi-structured data have emerged. They are commonly referred to as NoSQL databases, emphasizing the opposition to the strict schema used in SQL databases. Examples are <a href="http://www.mongodb.org/">MongoDB</a> or <a href="http://couchdb.apache.org/">CouchDB</a>. Relaxing the schema and normalization requirements may also give a boost to the performance as Bigtable [<a href="05boehme.html#19">19</a>] or HBase [<a href="05boehme.html#30">30</a>] demonstrate. Furthermore, new formats for encoding semi-structured data have been introduced, e.g., JSON [<a href="05boehme.html#22">22</a>].</p>

<p>While there have been considerable advances in the field of storing and retrieving semistructured data, transformations of semi-structured data still tend to be solutions written from scratch for each individual use case, with scarce tool support and little (code) reuse, despite being such a ubiquitous task. Except for the XML-centered XSLT [<a href="05boehme.html#21">21</a>] there is currently no dominant solution.</p>

<p>In the following we give an overview of existing languages for querying semi-structured data as approaches for transformation. As Metamorph is a flow-oriented language, similarities and differences to the aims and scope of other  flow-oriented languages are discussed in Section 2.2.</p>

<div class="divider-dot">&nbsp;</div>
<h4>2.1 Query and Transformation Languages</h4>

<p>The rise of semi-structured data and XML in particular triggered the development of a number of languages for querying and transforming such data (see [<a href="05boehme.html#4">4</a>, <a href="05boehme.html#13">13</a>] for overviews). The difference between query and transformation languages is often not clear-cut since transformation usually involves selecting (i.e. querying) those elements of the input data which should be transformed and included in the output data. Hence, transformation languages often include elements which allow querying a semi-structured data source. Well-known query and transformation languages for semi-structured data include XQuery [<a href="05boehme.html#10">10</a>] and XSLT [<a href="05boehme.html#21">21</a>]. Both rely on XPath [<a href="05boehme.html#8">8</a>] for addressing XML elements.</p>

<p>In his overview paper [<a href="05boehme.html#4">4</a>] Bailey distinguishes two main types of languages for element selection in semi-structured data: navigational languages and positional languages. In navigational languages elements are selected by describing a path through the semistructured data object (e.g. an XML document) leading from a start element (or context element) to the element that is to be selected. Positional languages in contrast select elements by describing patterns matching the elements that should be selected. XPath and consequently XQuery and XSLT use a navigatorial approach to locate elements in the XML data. Since this approach can lead to complex selection specifications [<a href="05boehme.html#7">7</a>], other query languages were developed that use a positional approach. A recent example of such languages is the XML query language Xcerpt [<a href="05boehme.html#7">7</a>]. In addition to using a positional approach for selecting data, Xcerpt has the ability to create graphical representations of Xcerpt scripts, a feature similar to Metamorph's visualization. See Section 4.7.2.</p>

<p>Allowing the selection of arbitrary elements in an input document can severely restrict the ability of a transformation processor to process a stream of semi-structured data. A point in case is XSLT which allows to refer to any element in the document using XPath expressions. In order to mitigate the effects this can have on the ability of XSLT processors to work on data streams (such as those created by SAX), Becker developed the Streaming Transformations for XML (STX) [<a href="05boehme.html#5">5</a>, <a href="05boehme.html#20">20</a>]. The core feature of this language is a selection language based on XPath 2.0, which only allows backward selection of elements.</p>

<p>Metamorph differs from the transformation languages described above in a number of ways. First, Metamorph is not bound to any specific data format such as XML but operates on an abstract data model instead (see Section 3.2). This data model is well-suited to represent the heavily structured data consisting of numerous small data fields that is often found in metadata. By excluding complex features such as namespaces or attributes the data model of the transformation language is kept concise. However, it is still possible to map XML onto this simpler data model. Second, in contrast to most other transformation languages, which follow the idea of transformation by querying, Metamorph is built from ground up on the concept of transforming a stream of events. Third, Metamorph differs from XSLT by relying on the positional approach for data addressing as opposed to the navigational approach.</p>

<p>Apart from query and transformation languages focusing on semi-structured data in XML format the emergence of NoSQL and distributed data processing frameworks such as <a href="http://hadoop.apache.org">Apache Hadoop</a> gave rise to new paradigms for distributed data processing such as <i>map-reduce</i> [<a href="05boehme.html#24">24</a>]. Building on this paradigm new languages have been developed to facilitate distributed processing of semi-structured data. Two examples are JAQL [<a href="05boehme.html#9">9</a>] and PIG [<a href="05boehme.html#41">41</a>]. Both combine declarative features with a classical iterative programming model. In contrast, Metamorph follows a purely declarative, flow-oriented programming model, and does not have built-in support for map-reduce at the language level. It has, however, been successfully used in combination with map-reduce (see also Section 5.1).</p>

<div class="divider-dot">&nbsp;</div>
<h4>2.2 Flow Languages</h4>

<p>Metamorph is a flow language, defining the transformation process in a declarative fashion. It shares the critique of control-flow orientation put forth by flow language advocates. Morrison, who refers to the flow concept as Data Stream Linkage Mechanism argues as follows: "[The Data Stream Linkage Mechanism] can increase the productivity of programmers and can result in programs that are easier to understand and maintain" [<a href="05boehme.html#40">40</a>]. In the context of Metamorph this means that domain experts can concentrate on declaratively defining how output is assembled from input without having to worry about control-flow aspects such as if-statements or loops. We argue that in the domain of metadata transformation this shift of focus is beneficial and facilitates the integration of domain experts in the development process.</p>

<p>Flow language advocates put forth another argument: Johnston points out in a survey article, that "[t]he original motivation for research into data flow was the exploitation of massive parallelism." [<a href="05boehme.html#37">37</a>]. The same point of view is also taken in [<a href="05boehme.html#29">29</a>, <a href="05boehme.html#44">44</a>]. The parallelism aspect of flow languages is <i>not</i> shared by Metamorph. Furthermore, Metamorph operates on rather small, self-contained data records (see also Section 3.2). For these reasons, there is no necessity to execute elements of the flow in parallel as parallelism may easily be achieved by splitting the input data along record boundaries and running several Metamoprh instances in parallel.</p>

<p>In summary, Metamorph uses the flow paradigm to enable declarative definition of transformations. It does not use the flow paradigm to enable parallelism.</p>

<div class="divider-full">&nbsp;</div>
<h3>3 Framework</h3>

<p>Before defining the data transformation language itself, the framework within which it operates needs to be defined: firstly, Metamorph employs a <i>Pipes and Filters</i> processing architecture to organize the data  flow (Section 3.1). Secondly, the data representation in Metamorph is based on a simple, generic model, which is presented in Section 3.2.</p>

<div align="center">
<img src="boehme-fig1.png" alt="boehme-fig1" width="457" height="172" border="0" vspace="10" class="borderGray" />
<p><i>Figure 1: A processing pipeline including a reader, a transformation, and a writer. The transformation is performed by a Metamorph object, configured via a transformation definition.</i></p>
</div>

<div class="divider-dot">&nbsp;</div>
<h4>3.1 Pipes and Filters Pattern</h4>

<p>As pointed out in Section 1, a transformation tool should not commit to a specific input or output format (universality). Consider the task of indexing a book catalog: we would need to read the book metadata, select the pieces of information to be indexed (title, author, subject etc.), and finally, pass this information to the indexer. Data may come from a variety of different sources: databases, network connections, local files etc. The indexer might be exchanged for a different one or even replaced with a viewer for debugging purposes. On an abstract level the following characteristics can be identified:</p>

<ol>
	<li style="padding-bottom: .5em;">Non-adjacent processing steps do not share information</li>

	<li style="padding-bottom: .5em;">Different sources of input exist</li>

	<li>Final results may be stored in different ways</li>
</ol>

<p>Given this situation, the software pattern literature suggests a <i>Pipes and Filters</i> pattern to be most expedient [<a href="05boehme.html#16">16</a>, p. 54]. Buschmann <i>et al</i>. define this architecture as follows:</p>

<p class="indentQuote"><i>"The Pipes and Filters architectural pattern divides the task of a system into several sequential processing steps. These steps are connected by the data flow through the system &#151; the output data of a step is the input to the subsequent step. Each processing step is implemented by a filter component"</i>. [<a href="05boehme.html#16">16</a>, p. 55]</p>

<p>Figure 1 shows how the transformation language Metamorph employs the <i>Pipes and Filters</i> pattern. Input data is read and converted to events defined by an abstract data model, which acts as an interface between the different processing stages (filters). The data model will be described in the next section. A Metamorph filter receives the events, transforms them, and outputs the result as a new stream of events. The transformation itself is encoded in an XML file, which we refer to as the <i>Metamorph definition</i>. Listing 1 shows the respective Java code, implementing the <i>Pipes and Filters</i> chain depicted in Figure 1. First, the <i>Pipes and Filters</i> objects are created. Second, they are connected to form a processing pipeline. Finally, the pipeline is started by reading the input data. The implementation thus corresponds to passive push filters in the <i>Pipes and Filters</i> taxonomy.</p>

<p>Passive filters are simpler than active ones as they do not need separate threads or processes and neither require buffering. If multi-threading became an issue in the future, it would be possible to equip individual filters with their own thread, making them active.</p>

<div align="center">
<img src="boehme-list2.png" alt="boehme-list2" width="728" height="191" border="0" />
<p><i>Listing 2: Constructing a processing pipeline according to the pattern depicted in Figure 1.</i></p>
</div>

<div class="divider-dot">&nbsp;</div>
<h4>3.2 Data Model and Event Interface</h4>

<p>To separate the different filters in a pipe from each other, an abstract data model needs to be established. It defines the interface by which filters connect and pass information to the next stage. To find a common denominator, we made the following assumptions:</p>

<ol>
	<li style="padding-bottom: .5em;">The semi-structured data intended for processing can be divided in self-contained units, which we will refer to as records.</li>

	<li style="padding-bottom: .5em;">The atomic unit of information is a literal that consists of a name and a value. In the current implementation both are of type <span class="codelg">String</span>. The rationale is to keep the implementation simple at the current state of development and to follow best practice of metadata formats in the cultural heritage domain, where the string data type is used almost exclusively.</li>

	<li>Literals may be grouped in entities. An entity may be contained within another entity. Entities have a name of type <span class="codelg">String</span>.</li>
</ol>

<p>The resulting data structure is depicted in Figure 2.</p>

<p>This data structure is never explicitly instantiated in the processing pipeline for reasons of efficiency, as described in Section 1. This means that there are no such classes as <span class="codelg">Record</span> or <span class="codelg">Entity</span>. Instead, the information contained in one record is passed from one filter to the next by means of events. This model of semi-structured data as a stream of events is similar to the Streaming API for XML (SAX) [<a href="05boehme.html#14">14</a>]. The events used by Metamorph are defined as Java interface shown in Listing 3. In contrast to SAX, Metamorph uses a smaller set of events and restricts the parameters of all events to simple strings so that no complex data structures (such as lists of attributes) have to be constructed.</p>

<div align="center">
<img src="boehme-fig2.png" alt="boehme-fig2" width="479" height="214" border="0" vspace="10" class="borderGray" />
<p><i>Figure 2: The generic data structure used to model semi-structured data.</i></p>
</div>

<div class="divider-gray">&nbsp;</div>

<div align="center">
<img src="boehme-list3.png" alt="boehme-list3" width="734" height="108" border="0" />
<p><i>Listing 3: The event interface implemented by the filters.</i></p>
</div>

<p>The rationale for this design decision is twofold: firstly, the event-based processing reduces object creation. It avoids having to explicitly create a <span class="codelg">Record</span> object and all the <span class="codelg">Entity</span>, <span class="codelg">Literal</span> and supporting <span class="codelg">List</span> objects. As object creation is costly [<a href="05boehme.html#45">45</a>], this results in faster code and addresses the efficiency challenge discussed in Section 1. Secondly, we avoid having to commit to a specific implementation of the data structure in Figure 2. Implementation decisions would always be application specific. For instance, using hash tables instead of arrays of linked lists to hold entities or literals would favor application scenarios which need random access, deciding otherwise would again mean optimizing for scenarios, in which ordered processing is important. The event-driven model is eclectic in that sense.</p>

<p>Listing 4 gives an example of a semi-structured piece of data. According to the StreamReceiver interface the serializer or reader would invoke the following methods on the next filter in the pipe: <span class="codelg">startRecord("118559796")</span>; <span class="codelg">startEntity("prefName")</span>; <span class="codelg">literal("forename", "Immanuel")</span>; and so forth, (<span class="codelg">"prefName"</span> is the preferred name of the person). The generic nature of the data model addresses the universality challenge pointed out in Section 1.</p>

<div align="center">
<img src="boehme-list4.png" alt="boehme-list4" width="731" height="264" border="0" />
<p><i>Listing 4: An example of a semi-structured piece of data, in a JSON-like syntax (repeated keys are not allowed in JSON, however common in semi-structured data).</i></p>
</div>

<div class="divider-full">&nbsp;</div>
<h3>4 Transformation Language</h3>

<p>From an implementation point of view, Metamorph corresponds to a filter in the pipes and filters architecture described in the previous section. A concrete instance is created according to an XML file which declares the transformations to be applied to the data flow. The flow comprises elements that select literals from the input data, as well as elements for processing and combining data. Figure 3 shows an example of a visual representation of such a data flow. The corresponding Metamorph definition is shown in Listing 5.</p>

<div align="center">
<img src="boehme-fig3.png" alt="boehme-fig3" width="704" height="402" border="0" vspace="10" class="borderGray" />
<p><i>Figure 3: Flowchart of a data transformation. Oval shapes depict inputs. Squares symbolize processing and combination steps, and circles output. The names of the generated literals are shown as arrow labels.</i></p>
</div>
<div class="divider-white">&nbsp;</div>
<div align="center">
<img src="boehme-list5.png" alt="boehme-list5" width="735" height="268" border="0" />
<p><i>Listing 5: A simple Metamorph definition to construct a short description of a person.</i></p>
</div>

<p>Imagine we want to build a service in which a short description of a person is needed. For instance: "Kant, Immanuel (1724&#151;1804) philosopher, professor, librarian". The data base provides semi-structured data similar to Listing 4. The data is actually a simplified version of the data provided by the Linked Open Data service of the DNB. Several steps are needed to assemble the output: the year of birth and death are extracted from a free text field via a regular expression matching four digit numbers. Professions are concatenated. Finally all parts are combined to form a single name value. Both using XML and making the language declarative lowers the entry barrier for domain experts, and thus adds to transparency (see discussion in Section 1). The example is simplistic of course: there is only one output. The output is itself not structured, just a string. In the following we present a broader selection of Metamorph's features.</p>

<div class="divider-dot">&nbsp;</div>
<h4>4.1 Selection</h4>

<p>To start transforming a record of semi-structured data, the pieces of data serving as inputs (see also Figure 3) need to be selected. In the simplest way this is done by providing a path expression. For instance <span class="codelg">prefName.forename</span> would address the String "Immanuel" in the sample data shown in Listing 4.</p>

<p>Listing 6 shows an example in Metamorph.</p>

<div align="center">
<img src="boehme-list6.png" alt="boehme-list6" width="733" height="44" border="0" />
<p><i>Listing 6: Receiving values from literals.</i></p>
</div>

<p>The dot character is used as delimiter to separate entities and literal names. Metamorph also supports path expressions containing wildcards. For instance, the star-wildcard <span class="codelg">"person*"</span> matches all literals with names starting with "person", such as "person name", "person age", etc. Apart from the star-wildcard, the question mark wildcard ("?") is supported. It matches exactly one arbitrary character. To match only specific characters Metamorph supports character sets in path expressions. The set "[abc]", for instance, matches one character "a", "b" or "c".</p>

<p>Additionally, sources can be concatenated using the pipe-character to express a logical or relationship: <span class="codelg">"creator|contributor"</span> would match both 'creator' and 'contributor'. The pipe connects complete source names. It does not apply to parts or characters. More elaborate path matching schemes are conceivable.</p>

<p>The current implementation of Metamorph uses a Trie [<a href="05boehme.html#27">27</a>] to efficiently match and dispatch incoming literals. The Trie has been extended to support basic regular expression matching. Its implementation follows the principles outlined in [<a href="05boehme.html#32">32</a>].</p>

<div class="divider-dot">&nbsp;</div>
<h4>4.2 Processing</h4>

<p>Elements for processing take one literal at a time (name-value pair) and perform a given operation on it. The result may be 0 to <i>n</i> output literals. An example is shown in Listing 7: a regular expression match is applied to the value of the birth literal. If a four digit number is found, it is returned as result; if not the result is void and processing is stopped. Processing elements can be chained and they may maintain state. This makes it possible to filter by occurrence, filter by uniqueness or to delay processing.</p>

<div align="center">
<img src="boehme-list7.png" alt="boehme-list7" width="727" height="71" border="0" />
<p><i>Listing 7: Processing data within the <span class="codelg">data</span> tag.</i></p>
</div>

<div class="divider-dot">&nbsp;</div>
<h4>4.3 Collection</h4>

<p>Collection elements are used to build one output literal from a combination of input literals. The example in Listing 8 for instance collects the sur- and forename, both of which are stored in separate literals, to combine them according to the pattern 'surname, forename'.</p>

<p>By default <span class="codelg">combine</span> waits until at least one value from each <span class="codelg">data</span> tag is received. If the collection is not complete on record end, no output is generated. After each output the state of <span class="codelg">combine</span> can be reset. If one <span class="codelg">data</span> tag receives literals repeatedly before the collection is complete only the last value will be retained.</p>

<div align="center">
<img src="boehme-list8.png" alt="boehme-list8" width="728" height="108" border="0" />
<p><i>Listing 8: Combining data from two different data sources.</i></p>
</div>

<p>The standard behavior of combine can be modified with several arguments: <span class="codelg">flushWith="entityname"</span> generates output on the end of each entity with name <i>entityname</i>. Variables in the output pattern which are not yet bound to a value, are replaced with the empty string. Use <span class="codelg">flushWith="record"</span> to set the record end as output trigger. <span class="codelg">reset="true"</span> enables the reset after output: already collected values are discarded. <span class="codelg">sameEntity="true"</span> will reset the combine after each entity end and thus emit combinations stemming from the same entities only.</p>

<p>Further collection elements include functionality for concatenation, building tuples or making a choice based on priorities.</p>

<div class="divider-dot">&nbsp;</div>
<h4>4.4 Entity Construction</h4>

<p>With the elements discussed so far, only the output of named values is possible. Many applications require the output of structured data, though. Structured output is achieved with the entity tag. Listing 9 shows how information about a creator of a media unit (its name stored in fields "100? .a" and role stored in "100? .4") is extracted from a MARC21 record and bundled within a "creator" entity. Entity tags may be nested to create more complex structures.</p>

<div align="center">
<img src="boehme-list9.png" alt="boehme-list9" width="730" height="91" border="0" />
<p><i>Listing 9: Combining named values in an entity.</i></p>
</div>

<div class="divider-dot">&nbsp;</div>
<h4>4.5 Recursion</h4>

<p>Pieces of data processed with Metamorph are by default sent to the next filter in the pipe. However, there is also the possibility to send them into a feedback loop. In this case the data reenters Metamorph just as if it came from the upstream filter in the pipe. This recursion is accomplished by prepending an '@' to the name of the data. Listing 10 shows an example. While recursive loops are possible with this technique, the main application is literal reuse: imagine two desired outputs partially sharing the same data and processing. The shared partial result can be distributed via the recursion mechanism. Listing 10 shows such a case where two versions of the format literal are generated.</p>

<div align="center">
<img src="boehme-list10.png" alt="boehme-list10" width="732" height="186" border="0" />
<p><i>Listing 10: Prepending '@' to the literal name to enable recursive processing.</i></p>
</div>

<div class="divider-dot">&nbsp;</div>
<h4>4.6 Language Implementation</h4>

<p>This section discusses specific implementation aspects of Metamorph. Firstly, why we chose XML as format for the definition files. And secondly, how Metamorph filters are instantiated based on such XML descriptions.</p>

<p><b>4.6.1 Metamorph Definitions in XML</b></p>

<p>The transformation performed by the Metamorph object is declared in XML. The choice in favor of XML is motivated by three arguments:</p>

<ol>
	<li style="padding-bottom: .5em;">The document object model behind XML is a tree with homogeneous nodes. The mapping of dataflow diagrams such as the one depicted in Figure 3 to an XML-structure (and vice versa) is straight-forward. The definitions are clear and homogeneous enough to keep the XML simple.</li>

	<li style="padding-bottom: .5em;">XML parsers for Java are available and mature. They provide syntax checking and build a document object model (DOM) from the XML code. The DOM may serve as an homogeneous abstract syntax tree (AST). Homogeneous ASTs are a fitting choice for non object-oriented languages (see [<a href="05boehme.html#43">43</a>, p. 94]).</li>

	<li>Schema-aware XML-editors are wide spread. They offer syntax checking, auto-completion and syntax highlighting based on a schema referenced in the XML and are thus a viable substitute for a full-edged IDE, at least for domain specific languages.</li>
</ol>

<p><b>4.6.2 Integration in Java</b></p>

<p>The mapping of XML tags to the Java objects implementing the flow is straight forward: each tag has a one-to-one correspondence to a Java class implementing it. The name of the tag is connected to the class name via a lookup table, manifested in a Java properties file. The attributes of the tag are mapped to setter-methods of the respective class and invoked via the Java Reflection API [<a href="05boehme.html#31">31</a>]. From a software engineering point of view this corresponds to the technique of <i>Dependency Injection</i> as outlined by Fowler [<a href="05boehme.html#26">26</a>]. In that sense the Metamorph XML file plays a similar role as the application context XML file in the <i>Dependency Injection</i> framework Spring [<a href="05boehme.html#36">36</a>].</p>

<div class="divider-dot">&nbsp;</div>
<h4>4.7 Further Features</h4>

<p>Metamorph offers a number of further features. Their detailed description would be beyond the scope of this paper, though. We therefore only briefly point out the most salient ones and refer the reader to the <i>Metamorph User Guide</i> [<a href="05boehme.html#2">2</a>] for more information.</p>

<p><b>4.7.1 Test Framework</b></p>

<p>As any piece of software, data transformations need to be tested. Doing this in Java can be very tedious, involving large amounts of so called "boilerplate code", i.e. sections of code that have to be included in many different places with little or no alteration. The Metamorph Java library therefore includes a test harness for transformations: test cases are defined as XML files comprising three parts. Firstly, an XML representation of the input data as an event stream or a reference to a data file and the corresponding reader. Secondly, the Metamorph definition to be tested or a reference to a Metamorph definition file. Thirdly and finally, the expected result. Modifiers can be used to indicate to the test framework whether the order of the data is supposed to matter. The test cases integrate into the JUnit framework [<a href="05boehme.html#28">28</a>] and therefore show in JUnit IDE plug-ins just as any other JUnit test case.</p>

<p><b>4.7.2 Visualization</b></p>

<p>As Metamorph definitions describe flows, they can easily be visualized. Metamorph contains a command line tool, which automatically translates the Metamorph XML to the graph description language used by <a href="http://www.graphviz.org/">GraphViz</a>. Based on the resulting gv-file a flow diagram can be generated by applying Graphviz's <span class="codelg">dot</span> layouter. Figure 3 is an example of such a visualization. Its source code is depicted in Listing 5. Such visualizations further increase transparency (see challenges outlined in Section 1).</p>

<p><b>4.7.3 Maps and external Data Sources</b></p>

<p>Table lookup is a pervasive task in metadata transformation. Consider for example replacing ISO country codes with full names or expanding abbreviations (ed becomes editor, prf becomes performer, etc.). To address this, maps can be defined in the Metamorph definition. They constitute additional input to processing elements such as <span class="codelg">lookup</span>, <span class="codelg">whitelist</span>, <span class="codelg">blacklist</span> or <span class="codelg">setreplace</span>. Sometimes these tables or maps are held in databases or accessed by other means. Any Java object implementing the <span class="codelg">Map</span> interface can be registered with the Metamorph instance to act as map. The registration can be performed any time prior to processing.</p>

<p><b>4.7.4 Macros and XInclude</b></p>

<p>Metamorph offers a basic macro support to avoid repetition on the code level. Macros are expanded before visualization. Furthermore, XInclude is supported to foster code reuse. Both features are still subject to change and will be further developed in future releases.</p>

<div class="divider-full">&nbsp;</div>
<h3>Applications</h3>

<p>Metamorph is an integral part of several services provided by the German National Library, two of which are presented in this section. A third example discusses a project in which a project-specific data mapping technology is currently being replaced by Metamorph.</p>

<div class="divider-dot">&nbsp;</div>
<h4>5.1 Culturegraph</h4>

<p>As more and more cultural heritage data become openly available, the opportunities to combine data sets to build new services and applications multiply. To do so, however, relations between as yet unconnected data sets need to be created. Culturegraph is an open platform for connecting and processing metadata primarily from the library domain, developed by the German National Library and partner institutions. The data is processed on a <a href="http://hadoop.apache.org/">Hadoop Cluster</a>. All data transformations in the Culturegraph platform are realized with Metamorph. This includes:</p>

<ol>
	<li style="padding-bottom: .5em;">Transformation of input data in the MARC21 format to the internal data format of Culturegraph.</li>

	<li style="padding-bottom: .5em;">Matching bibliographic records with each other, unique properties identifying the records are calculated based on their metadata content.</li>

	<li style="padding-bottom: .5em;">Transformation of records to <a href="http://lucene.apache.org/">Lucene</a> documents for indexing.</li>

	<li>Transformation of records for presentation in HTML (full view or search result preview) and RDF.</li>
</ol>

<p>The <a href="http://www.culturegraph.org">Culturegraph</a> platform, online since 2011, currently stores, matches and indexes over 120 million bibliographic records from Germany
and Austria.</p>

<div class="divider-dot">&nbsp;</div>
<h4>5.2 DNB Linked Open Data</h4>

<p>In 2009, the German National Library started to publish its extensive metadata collections as linked open data [<a href="05boehme.html#34">34</a>], aiming to provide library metadata in an easily accessible format. Currently, RDF is offered. This data can be accessed via data dumps, through the web portal of the German National Library, or via <a href="http://www.loc.gov/standards/sru/">SRU</a> and <a href="http://www.openarchives.org/pmh/">OAI-PMH</a> (Open Archives Initiative Protocol for Metadata Harvesting) interfaces.</p>

<p>As of now, the services offer the following datasets that are transformed from the internal library format (Pica+) into RDF using Metamorph. Currently the data comprises 10.3m bibliographical records, 7.2m records on persons, 1.2m records on organizations, 1.1m records of controlled vocabulary for geographic locations, congresses, etc., and 0.2m records on subject headings. The transformations are performed both on-demand (web portal, SRU, OAI-PMH) and offline (data dump).</p>

<p>Further information on the <a href="http://www.dnb.de/EN/Service/DigitaleDienste/LinkedData/linkeddata_node.html">linked data service</a> of the German National Library is available. </p>

<div class="divider-dot">&nbsp;</div>
<h4>5.3 DNB Portal Search</h4>

<p>The German National Library provides a <a href="http://portal.dnb.de/">web-based portal</a> for searching the library catalog. The search engine behind this portal relies on <a href="https://lucene.apache.org/solr/">Apache Solr</a>. For the indexing process, the bibliographic records in Pica+ format need to be transformed into Solr documents. This does not only involve the conversion of individual records but also requires the expansion of record references. Currently, transformations are specified in a custom XML-based configuration language that became quite complex and powerful over time. However, despite this power, the language is highly geared towards the task of resolving references and converting Pica+ records into Solr documents and cannot be used for other conversion tasks.</p>

<p>Metamorph offers the opportunity to replace this highly task specific language with a more general one, allowing the German National Library to consolidate the software technology stack and to focus development efforts on a single transformation language.</p>

<p>In a pilot study, the task specific XML configuration was translated into Metamorph. Large parts of the translation were performed automatically with a Perl script. The remaining parts were translated manually. All in all, it took one programmer half a day to convert the XML-based configuration to Metamorph. No major problems were encountered. The programmer emphasized in particular the usefulness of the pipes and filters architecture as it allowed her to easily test the transformation on individual records and to verify the correctness of the transformations with unit tests.</p>

<div class="divider-full">&nbsp;</div>
<h3>6 Discussion</h3>

<div class="divider-dot">&nbsp;</div>
<h4>6.1 Scope of Metamorph</h4>

<p>In Sections 3.1 and 3.2 we explained how Metamorph combines a <i>Pipes and Filters</i> architecture with an event-based processing paradigm for data structures. The motivation was to implement a format-agnostic transformation language with high processing efficiency. This optimization comes at a cost: the data and the processing task must fit into this framework. In other words, Metamorph can only implement a processing task which can be accomplished in one start-to-end pass through the data record. In particular, it is not possible to follow references in a data structure, a feature for instance exhibited by the <a href="http://www.loc.gov/standards/mets/">METS</a> format: <i>"Within a METS document it is often desirable to associate information in one section of the document with information in a different section. This internal linking is accomplished by means of XML ID/IDREF attributes."</i> [<a href="05boehme.html#23">23</a>].</p>

<p>Having said that, a large number of processing tasks do not require the resolution of references and fit well into the class of tasks solvable within the event-based processing paradigm. (See also the applications presented in Section 5.)</p>

<div class="divider-dot">&nbsp;</div>
<h4>6.2 Usability</h4>

<p>An aim of Metamorph is to enable domain experts to perform metadata conversions themselves. Over the last years we were able to gather feedback concerning the usability of Metamorph from users with backgrounds as library metadata experts, information scientists or software developers in libraries. The main source of feedback was a series of hands-on workshops on the analysis of library metadata [<a href="05boehme.html#17">17</a>, <a href="05boehme.html#18">18</a>]. Participants in the workshops who had a solid technical background quickly grasped the fundamentals of Metamorph and were able to write simple scripts. Users who were not familiar with XML and working with integrated development environments or XML editors found it hard to follow the workshops, though. Interestingly, domain experts quickly understood and accepted the declarative nature and data-driven execution of Metamorph, while users with prior programming experience often unconsciously assumed that Metamorph scripts were executed from top to bottom like a program in a typical imperative programming language.</p>

<p>In the workshops we observed that many challenges the workshop participants encountered were not rooted in the usage of Metamorph but in the fact that library metadata itself is quite complex. This complexity requires users to consider various special cases in their data conversions which might not be immediately obvious. A case in point is the processing of dates of birth and death, which was one of the exercises in the workshop. Intuitively one assumes that persons only have a single date of birth and a single date of death. However, in the integrated authority file (Gemeinsame Normdatei (GND)), which provided the database for the workshop, this is not always given. The integrated authority file allows recording multiple dates for a person to cover cases in which competing dates exist. The feature is also facilitated for storing different formats of dates (such as dates consisting only of the year and those also including day and month). In the workshops, participants (including most domain experts) were surprised when the number of dates found in the authority file was larger than the number of persons. After having learned that there might be multiple dates of birth and death for a person, the main question was usually how these additional date values should be interpreted within the domain. Once the participants had decided on an interpretation of the data, they implemented the Metamorph solution in a straightforward manner.</p>

<p>In summary, we observed that Metamorph makes metadata conversion accessible for domain experts. The workshops showed, though, that users need to have the ability to develop a structured mental picture of their conversions and to identify corner cases in the conversions which they want to describe. Additionally, learning Metamorph was much easier for those users who were versed in computing and already familiar with technologies such as XML and XML editors.</p>

<div class="divider-dot">&nbsp;</div>
<h4>6.3 Future Work</h4>

<p>While Metamorph has proven its value in the library metadata domain where it is already part of the production environment, it is still a work in progress. To become an entirely domain-independent tool, several issues need to be addressed and will be the main focus of future work.</p>

<p><b>6.3.1 Type System</b></p>

<p>As pointed out in Section 3.2, Metamorph uses only Strings. In the field of library metadata this is a viable and necessary assumption: all data are Strings. Numerical computations do not exist. To reach beyond library metadata, a type system is indispensable.</p>

<p><b>6.3.2 Function Libraries</b></p>

<p>Metamorph currently contains a number of built-in functions and collectors that cover metadata processing in the library domain. New functions can be added as pointed out in Section 4.7 and macros can be shared by means of the XInclude mechanism. In domains with entirely different processing needs, however, the currently used mechanisms might be cumbersome. It would be preferable to build libraries of functions and macros for different domains that can be included as needed.</p>

<p><b>6.3.3 Syntax and Parsing</b></p>

<p>In the current version of Metamorph, XML forms the basis for Metamorph definitions, as pointed out in Section 4.6.1. The just discussed venues of future work will likely go beyond the expressiveness of XML. Especially, a type system requires a level of expressiveness which can hardly be achieved with XML; not to mention elegance and ease of writing.</p>

<div class="divider-dot">&nbsp;</div>
<h4>6.4 Conclusion</h4>

<p>In this paper we presented a new language &#151; Metamorph &#151; for semi-structured data transformation. It is declarative, data flow-oriented, integrated in Java and expressed in XML. Metamorph has a narrower scope than XSLT. Its event-based processing model is, however, more efficient with respect to the DOM centered processing model of XSLT. Furthermore, Metamorph can easily be visualized and facilitates communication with domain experts. While Metamorph is still subject to changes and modifications as we discussed in Section 6.3, it is already a part of the production environment of the German National Library (see Section 5), and as pointed out in the Introduction, <a href="https://culturegraph.github.com">Metamorph</a> is available Open Source.</p>

<div class="divider-full">&nbsp;</div>
<h3>References</h3>

<p><a name="1">[1]</a> <i><a href="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/">RDF/XML Syntax Specification (Revised)</a></i>, February 2004.</p>

<p><a name="2">[2]</a> <a href="https://github.com/culturegraph/metafacture-core/wiki">Metafacture wiki</a>, 2013.</p>

<p><a name="3">[3]</a> S. Abiteboul. <a href="http://ilpubs.stanford.edu:8090/144/">Querying semi-structured data</a>. In <i><i>Database Theory</i> &#151; ICDT '97</i>, pages 1&#151;18. ACM, 1997.</p>

<p><a name="4">[4]</a> J. Bailey, F. Bry, T. Furche, and S. Schaffert. Web and semantic web query languages: A survey. In <i>Reasoning Web</i>, pages 35&#151;133, 2005. <a href="https://doi.org/10.1007/11526988_3">http://doi.org/10.1007/11526988_3</a></p>

<p><a name="5">[5]</a> O. Becker. <i><a href="http://nbn-resolving.de/urn:nbn:de:kobv:11-10035056">Serielle Transformationen von XML Probleme, Methoden, L&#246;sungen</a></i>.
PhD thesis, Humboldt Universit&#228;t zu Berlin, Berlin, Germany, 2004.</p>

<p><a name="6">[6]</a> O. Ben-Kiki, C. Evans, and I. d&#246;t Net. <i><a href="http://www.yaml.org/spec/1.2/spec.html">YAML Ain't Markup Language (YAML) Version 1.2</a></i>, October 2009.</p>

<p><a name="7">[7]</a> S. Berger, F. Bry, S. Schaffert, and C. Wieser. Xcerpt and visxcerpt: From pattern-based to visual querying of xml and semistructured data. In <i>Proc. Intl. Conference on Very Large Databases (VLDB03), Demonstrations Track</i>, Berlin, Germany, 2003.</p>

<p><a name="8">[8]</a> A. Berglund, S. Boag, D. Chamberlin, M.F. Fernandez, M. Kay, J. Robie, and J. Sim&#233;on. <i><a href="http://www.w3.org/TR/2007/REC-xpath20-20070123/">XML path language (XPath) 2.0</a></i>. W3C, January 2007.</p>

<p><a name="9">[9]</a> K. S. Beyer, V. Ercegovac, R. Gemulla, A. Balmin, M. Eltabakh, C. Kanna, F. Ozcan, and E. J. Shekita. Jaql: A scripting language for large scale semistructured data analysis. In <i>Proceedings of the VLDB Endowment</i>, volume 4, Seattle, Washington, 2011.</p>

<p><a name="10">[10]</a> S. Boag, D. Chamberlin, M. F. Fern&#225;ndez, D. Florescu, J. Robie, and J. Sim&#233;on. <i>XQuery 1.0: An XML Query Language Second Edition</i>, December 2010.</p>

<p><a name="11">[11]</a> T. Bray, J. Paoli, and C.M. Sperberg-McQeen. <i><a href="http://www.w3.org/TR/1998/REC-xml-19980210.html">Extensible Markup Language (XML) 1.0</a></i>, February 1998.</p>

<p><a name="12">[12]</a> T. Bray, J. Paoli, C.M. Sperberg-McQeen, E. Maler, and F. Yergeau. <i><a href="http://www.w3.org/TR/2008/REC-xml-20081126/">Extensible Markup Language (XML) 1.0 (Fifth Edition)</a></i>, November 2008.</p>

<p><a name="13">[13]</a> J. Broekstra, C. Fluit, and F. van Marelen. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.7.4471&amp;rep=rep1&amp;type=pdf">The state of the art on representation and query languages for semistructured data</a>. Technical report, AIdministrator Nederland BV, 2000. Deliverable 8 of the EU-IST On-To-Knowledge (IST-1999-10132) project.</p>

<p><a name="14">[14]</a> D. Brownell. <i>Sax2</i>. O'Reilly Media, Incorporated, 2002.</p>

<p><a name="15">[15]</a> P. Buneman. Semistructured data. In <i>Proceedings of the sixteenth ACM SIGACTSIGMOD-SIGART symposium on Principles of database systems</i>, pages 117&#151;121. ACM, 1997. <a href="https://doi.org/10.1145/263661.263675">http://doi.org/10.1145/263661.263675</a></p>

<p><a name="16">[16]</a> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal. <i>A system of patterns: Pattern-oriented software architecture</i>. Wiley, 1996.</p>

<p><a name="17">[17]</a> C. B&#246;hme. <a href="http://swib.org/swib13/">Analysis of library metadata with metafacture</a>. <i>Workshop at Semantic Web in Libraries Conference (SWIB '13)</i>, November 2013.</p>

<p><a name="18">[18]</a> C. B&#246;hme. <a href="http://swib.org/swib14/">Analysis of library metadata with metafacture</a>. <i>Workshop at Semantic Web in Libraries Conference (SWIB '14)</i>, December 2014.</p>

<p><a name="19">[19]</a> F. Chang, J. Dean, S. Ghemawat, W.C. Hsieh, D.A.Wallach, M. Burrows, T. Chandra, A. Fikes, and R.E. Gruber. Bigtable: A distributed storage system for structured data. <i>ACM Transactions on Computer Systems (TOCS)</i>, 26(2):4, 2008. <a href="https://doi.org/10.1145/1365815.1365816">http://doi.org/10.1145/1365815.1365816</a></p>

<p><a name="20">[20]</a> P. Cimprich, O. Becker, C. Nentwich, H. Jirou&#353;ek, M. Batsis, P. Brown, and M. Kay. <i><a href="http://stx.sourceforge.net/documents/spec-stx-20070427.html">Streaming Transformations for XML (STX)</a></i>, April 2007.</p>

<p><a name="21">[21]</a> J. Clark. <i><a href="http://www.w3.org/TR/xslt">XSL Transformations (XSLT)</a></i>. W3C, November 1999.</p>

<p><a name="22">[22]</a> D. Crockford. <i><a href="https://tools.ietf.org/html/rfc4627">The application/json Media Type for JavaScript Object Notation (JSON)</a></i>. Network Working Group, July 2006. RFC 4627.</p>

<p><a name="23">[23]</a> M.V. Cundiff. An introduction to the metadata encoding and transmission standard (mets). <i>Library Hi Tech</i>, 22(1):52&#151;64, 2004. <a href="https://doi.org/10.1108/07378830410524495">http://doi.org/10.1108/07378830410524495</a></p>

<p><a name="24">[24]</a> J. Dean and S. Ghemawat. Mapreduce: simplified data processing on large clusters. <i>Communications of the ACM</i>, 51:107&#151;113, 2008. <a href="https://doi.org/10.1145/1327452.1327492">http://doi.org/10.1145/1327452.1327492</a></p>

<p><a name="25">[25]</a> G. Fischer, E. Giaccardi, Y. Ye, A.G. Sutcliffe, and N. Mehandjiev. Meta-design: a manifesto for end-user development. <i>Communications of the ACM</i>, 47(9):33&#151;37, 2004. <a href="https://doi.org/10.1145/1015864.1015884">http://doi.org/10.1145/1015864.1015884</a></p>

<p><a name="26">[26]</a> M. Fowler. <i><a href="http://martinfowler.com/articles/injection.html">Inversion of control containers and the dependency injection pattern</a></i>, 2004.</p>

<p><a name="27">[27]</a> E. Fredkin. Trie memory. <i>Commun. ACM</i>, 3(9):490&#151;499, September 1960. <a href="https://doi.org/10.1145/367390.367400">http://doi.org/10.1145/367390.367400</a></p>

<p><a name="28">[28]</a> E. Gamma and K. Beck. <a href="http://junit.sourceforge.net/doc/cookstour/cookstour.htm">Junit: A cook's tour</a>. <i>Java Report</i>, 4(5):27&#151;38, 1999.</p>

<p><a name="29">[29]</a> D. Gelernter and N. Carriero. Coordination languages and their significance. <i>Commun. ACM</i>, 35(2):97&#151;107, February 1992. <a href="https://doi.org/10.1145/129630.129635">http://doi.org/10.1145/129630.129635</a></p>

<p><a name="30">[30]</a> L. George. <i>HBase: The Definitive Guide</i>. O'Reilly Media, 2011.</p>

<p><a name="31">[31]</a> J. Gosling. <i><a href="https://docs.oracle.com/javase/specs/">The Java language specification</a></i>. Prentice Hall, 2000.</p>

<p><a name="32">[32]</a> D. Gusfield. <i>Algorithms on strings, trees and sequences: computer science and computational biology</i>. Cambridge University Press, 1997.</p>

<p><a name="33">[33]</a> R. Hacker. Bibliothekarisches grundwissen. 2008.</p>

<p><a name="34">[34]</a> J. Hannemann and J. Kett. <a href="http://conference.ifla.org/past-wlic/2010/149-hannemann-en.pdf">Linked data for libraries</a>.<i> World Library and Information Congress: 76th IFLA General Conference and Assembly</i>, August 2010.</p>

<p><a name="35">[35]</a> G. Henze, Editor. <i><a href="http://nbn-resolving.de/urn:nbn:de:101-2007072711">Regeln f&#252;r die alphabetische Katalogisierung in wissenschaftlichen Bibliotheken: RAK-WB</a></i>. Deutsche Nationalbibliothek, 2007.</p>

<p><a name="36">[36]</a> R. Johnson. <i>Expert one-on-one J2EE design and development</i>. Wrox, 2002.</p>

<p><a name="37">[37]</a> W.M. Johnston, JR Hanna, and R.J. Millar. Advances in data flow programming languages. <i>ACM Computing Surveys (CSUR)</i>, 36(1):1&#151;34, 2004. <a href="https://doi.org/10.1145/1013208.1013209">http://doi.org/10.1145/1013208.1013209</a></p>

<p><a name="38">[38]</a> O. Lassila and R. R. Swick. <i><a href="http://www.w3.org/TR/1999/REC-rdf-syntax-19990222/">Resource Description Framework (RDF) Model and Syntax Specification</a></i>, February 1999.</p>

<p><a name="39">[39]</a> M. Mernik, J. Heering, and A.M. Sloane. When and how to develop domain-specific languages. <i>ACM computing surveys (CSUR)</i>, 37(4):316&#151;344, 2005.</p>

<p><a name="40">[40]</a> J. P. Morrison. Data stream linkage mechanism. <i>IBM Syst. J.</i>, 17(4):383&#151;408, December 1978. <a href="https://doi.org/10.1147/sj.174.0383">http://doi.org/10.1147/sj.174.0383</a></p>

<p><a name="41">[41]</a> C. Olston, B. Reed, U. Srivastava, R. Kumar, and A. Tomkins. Pig latin: a not-so-foreign language for data processing. In <i>Proceedings of the 2008 ACM SIGMOD
international conference on Management of data</i>, pages 1099&#151;1110. ACM, 2008. <a href="https://doi.org/10.1145/1376616.1376726">http://doi.org/10.1145/1376616.1376726</a></p>

<p><a name="42">[42]</a> Y. Papakonstantinou, H. Garcia-Molina, and J. Widom. Object exchange across heterogeneous information sources. In Data Engineering, 1995. <i>Proceedings of the Eleventh International Conference on</i>, pages 251&#151;260. IEEE, 1995. <a href="https://doi.org/10.1109/ICDE.1995.380386">http://doi.org/10.1109/ICDE.1995.380386</a></p>

<p><a name="43">[43]</a> T. Parr. <i>Language implementation patterns: create your own domain-specific and general programming languages</i>. Pragmatic Bookshelf, 2009.</p>

<p><a name="44">[44]</a> M. L. Scott. <i>Programming Language Pragmatics</i>. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 3rd edition, 2009.</p>

<p><a name="45">[45]</a> J. Shirazi. <i>Java performance tuning</i>. O'Reilly Media, Incorporated, 2003.</p>

<p><a name="46">[46]</a> A. Sutcliffe, N. Mehandjiev, et al. End-user development. <i>Communications of the ACM</i>, 47(9):31&#151;32, 2004. <a href="https://doi.org/10.1145/1015864.1015883">http://doi.org/10.1145/1015864.1015883</a></p>

<div class="divider-full">&nbsp;</div>
<h3>About the Authors</h3>

<table border="0"  cellpadding="6" bgcolor="#FFFFFF"> 
<tr>
<td align="center"><img src="geipel.jpg" class="border" alt="geipel" width="100" height="121" /></td>
<td>
<p class="blue"><b>Markus Michael Geipel</b> graduated with distinction from Technische Universit&#228;t M&#252;nchen in Computer Science and earned a doctorate from the Swiss Federal Institute of Technology, Zurich. In 2011 he joined the German National Library where he worked on the German Digital Library (DDB) and created the software architecture of <a href="http://culturegraph.org">culturegraph.org</a>. Together with Christoph B&#246;hme, he founded the Open Source Project Metafacture/Metamorph to facilitate the processing of bibliographic metadata. Since 2013 Dr. Geipel has worked on software architecture for machine learning and data analytics at Siemens Corporate Technology. His latest open source project is <a href="https://github.com/siemens/omniproperties">Omniproperties</a>. </p>
</td>
</tr>
</table>

<div class="divider-full">&nbsp;</div>

<table border="0"  cellpadding="6" bgcolor="#FFFFFF"> 
<tr>
<td align="center"><img src="boehme.jpg" class="border" alt="boehme.jpg" width="100" height="146" /></td>
<td>
<p class="blue"><b>Christoph B&#246;hme</b> graduated from Technical University Ilmenau (Germany) in computer science and received a PhD in Psychology from the University of Birmingham (UK).  Since 2011 he has worked at the Germany National Library. Together with Markus M. Geipel, he founded the open source project Metafacture/Metamorph to facilitate the processing of bibliographic metadata. In 2013 he assumed his present position as head of a software development group at the German National Library. He is the current maintainer and lead developer of Metamorph/Metafacture. </p>
</td>
</tr>
</table>

<div class="divider-full">&nbsp;</div>

<table border="0"  cellpadding="6" bgcolor="#FFFFFF"> 
<tr>
<td align="center"><img src="hannemann.jpg" class="border" alt="hannemann" width="100" height="89" /></td>
<td>
<p class="blue"><b>Jan Hannemann</b> received his PhD in Computer Science from the University of British Columbia (Canada). While working for the German National Library he was the head of the System Innovation group and managed several data-focused projects, such as the research and development project <a href="http://theseus.pt-dlr.de/en/922">CONTENTUS</a> and the creation of Germany's first Linked Open Data <a href="http://www.dnb.de/EN/lds">service</a> for bibliographic data, for which Metafacture/Metamorph was first used. He is currently working as a product manager for Google. </p>
</td>
</tr>
</table>

<div class="divider-full">&nbsp;</div>

 <!-- Standard Copyright line here  -->

<div class="center">

<p class="footer">Copyright &copy; 2015 Markus Michael Geipel, Christoph B&#246;hme, and Jan Hannemann</p>  
  </div>
</td>
 </tr>
</table>

<table width="100%" border="0" align="center" cellpadding="0" cellspacing="0">
  <tr>
    <td height="1" bgcolor="#2b538e"><img src="../../../img2/transparent.gif" alt="transparent image" width="100" height="2" /></td>
  </tr>
</table>

</td></tr></table>
</td></tr></table>
</form>

</body>
</html>